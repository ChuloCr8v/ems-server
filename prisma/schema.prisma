generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Notification {
  id          String    @id @default(uuid())
  recipientId String    @db.Uuid
  actorId     String?   @db.Uuid
  prospectId  String?   @db.Uuid
  type        String
  message     String
  read        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  actor       User?     @relation("NotificationActor", fields: [actorId], references: [id])
  prospect    Prospect? @relation(fields: [prospectId], references: [id])
  recipient   User      @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
}

model User {
  id                    String             @id @default(uuid()) @db.Uuid
  eId                   String?            @unique
  personalEmail         String?            @unique
  email                 String?            @unique
  firstName             String
  lastName              String
  phone                 String?
  workPhone             String?
  role                  String?
  gender                String
  duration              String?
  jobType               JobType?
  country               String?
  state                 String?
  address               String?
  startDate             DateTime?
  status                Status             @default(PENDING)
  userRole              Role[]
  maritalStatus         MaritalStatus?
  levelId               String?            @db.Uuid
  prospectId            String?            @unique @db.Uuid
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  dateOfBirth           DateTime?
  approvals             Approval[]
  approver              Approver[]
  assignments           Assignment[]
  bank                  Bank?
  claims                Claim[]
  comment               Comment[]
  contacts              Contacts?
  departmentCreator     Department?        @relation("departmentCreator")
  faultReporter         Fault[]            @relation("reportedBy")
  faultResolver         Fault[]            @relation("resolvedBy")
  invite                Invite[]
  requestDoa            LeaveRequest[]     @relation("deedOfAssignement")
  requests              LeaveRequest[]     @relation("user")
  notificationActor     Notification[]     @relation("NotificationActor")
  notificationRecipient Notification[]     @relation("NotificationRecipient")
  offboarding           Offboarding?
  payroll               Payroll?
  payComponent          PayrollComponent[]
  payslip               Payslip[]
  responses             Response[]

  userDocuments     Upload[]     @relation("UserDocuments")
  level             Level?       @relation(fields: [levelId], references: [id])
  prospect          Prospect?    @relation(fields: [prospectId], references: [id], onDelete: Cascade)
  UserTask          UserTask[]
  departments       Department[] @relation("DepartmentToUser")
  prospectDocuments Upload[]     @relation("ProspectDocuments")

  createdTasks  Task[] @relation("CreatedTasks")
  approvedTasks Task[] @relation("ApprovedTasks")

  @@index([email])
  @@index([eId])
  @@index([firstName, lastName])
  @@index([levelId])
}

model Department {
  id           String            @id @default(uuid()) @db.Uuid
  name         String            @unique
  createdById  String?           @unique @db.Uuid
  status       DepartmentStatus? @default(ACTIVE)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @default(now()) @updatedAt
  approver     Approver[]
  createdBy    User?             @relation("departmentCreator", fields: [createdById], references: [id])
  prospects    Prospect[]        @relation("DepartmentToProspect")
  TaskCategory TaskCategory[]    @relation("DepartmentToTaskCategory")
  user         User[]            @relation("DepartmentToUser")
}

model Prospect {
  id           String         @id @default(uuid()) @db.Uuid
  email        String         @unique
  firstName    String         @default("")
  lastName     String         @default("")
  phone        String
  gender       String
  role         String
  duration     String?
  startDate    DateTime
  jobType      JobType
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  invite       Invite[]
  notification Notification[]
  upload       Upload[]
  user         User?
  departments  Department[]   @relation("DepartmentToProspect")
}

model Invite {
  id             String    @id @default(uuid()) @db.Uuid
  email          String
  token          String    @unique
  status         Status    @default(PENDING)
  createdAt      DateTime  @default(now())
  expiresAt      DateTime
  acceptedAt     DateTime?
  declinedAt     DateTime?
  sentById       String?   @db.Uuid
  prospectId     String    @db.Uuid
  declineReasons String[]
  comment        Comment[]
  prospect       Prospect  @relation(fields: [prospectId], references: [id], onDelete: Cascade)
  sentBy         User?     @relation(fields: [sentById], references: [id])
}

model Level {
  id           String             @id @default(uuid()) @db.Uuid
  name         String
  rank         Int
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  entitlements LevelEntitlement[]
  users        User[]
}

model Upload {
  id                String            @id @default(uuid()) @db.Uuid
  name              String
  size              Int
  type              String
  bytes             Bytes?
  key               String?
  order             Int?
  uri               String?
  prospectId        String?           @db.Uuid
  userId            String?           @db.Uuid
  offboardingId     String?           @db.Uuid
  commentId         String?           @db.Uuid
  handoverId        String?           @db.Uuid
  paymentId         String?           @db.Uuid
  assetId           String?           @db.Uuid
  requestId         String?           @db.Uuid
  publicId          String?           @unique
  secureUrl         String?           @unique
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  guarantorId       String?           @db.Uuid
  claimId           String?
  taskId            String?           @db.Uuid
  asset             Asset?            @relation("AssetImages", fields: [assetId], references: [id])
  claim             Claim?            @relation(fields: [claimId], references: [id])
  comment           Comment?          @relation(fields: [commentId], references: [id])
  guarantor         GuarantorContact? @relation(fields: [guarantorId], references: [id])
  handover          HandoverDocument? @relation(fields: [handoverId], references: [id])
  offboarding       Offboarding?      @relation(fields: [offboardingId], references: [id])
  payment           Payment?          @relation(fields: [paymentId], references: [id])
  prospect          Prospect?         @relation(fields: [prospectId], references: [id], onDelete: Cascade)
  request           LeaveRequest?     @relation(fields: [requestId], references: [id])
  Task              Task?             @relation(fields: [taskId], references: [id])
  userDocuments     User?             @relation("UserDocuments", fields: [userId], references: [id])
  prospectDocuments User[]            @relation("ProspectDocuments")
}

model Contacts {
  id        String             @id @default(uuid()) @db.Uuid
  userId    String             @unique @db.Uuid
  createdAt DateTime           @default(now())
  updatedAt DateTime           @default(now()) @updatedAt
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  emergency EmergencyContact[]
  guarantor GuarantorContact[]
  nextOfKin NextOfKin[]
}

model Bank {
  id            String   @id @default(uuid()) @db.Uuid
  bankName      String
  accountName   String
  accountNumber String
  userId        String?  @unique @db.Uuid
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User?    @relation(fields: [userId], references: [id])
}

model NextOfKin {
  id        String    @id @default(uuid()) @db.Uuid
  firstName String
  lastName  String
  phone     String
  contactId String?   @db.Uuid
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  address   String?
  contacts  Contacts? @relation(fields: [contactId], references: [id])
}

model EmergencyContact {
  id           String    @id @default(uuid()) @db.Uuid
  firstName    String
  lastName     String
  phone        String
  contactId    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  address      String?
  relationship String?
  contacts     Contacts? @relation(fields: [contactId], references: [id])
}

model GuarantorContact {
  id           String    @id @default(uuid()) @db.Uuid
  firstName    String
  lastName     String
  phone        String
  contactId    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  address      String?
  relationship String?
  contacts     Contacts? @relation(fields: [contactId], references: [id])
  document     Upload[]
}

model Comment {
  id            String            @id @default(uuid()) @db.Uuid
  comment       String
  userId        String?           @db.Uuid
  inviteId      String?           @db.Uuid
  offboardingId String?           @db.Uuid
  paymentId     String?           @db.Uuid
  handoverId    String?           @db.Uuid
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  handover      HandoverDocument? @relation(fields: [handoverId], references: [id])
  invite        Invite?           @relation(fields: [inviteId], references: [id])
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
  payment       Payment?          @relation(fields: [paymentId], references: [id])
  user          User?             @relation(fields: [userId], references: [id])
  uploads       Upload[]
}

/// ///////////////////////////// ASSETS ///////////////////////
model Asset {
  id           String         @id @default(uuid()) @db.Uuid
  assetId      String         @unique
  name         String
  serialNo     String?        @unique
  category     AssetCategory?
  purchaseDate DateTime?
  vendor       String?
  cost         Float?
  description  String?
  isReturned   Boolean?       @default(false)
  status       AssetStatus?   @default(AVAILABLE)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  assignments  Assignment[]
  faults       Fault[]
  assetImages  Upload[]       @relation("AssetImages")
}

model Assignment {
  id            String            @id @default(uuid())
  assetId       String            @db.Uuid
  userId        String            @db.Uuid
  assignedAt    DateTime
  retrievedAt   DateTime?
  notes         String?
  condition     String?
  status        AssignmentStatus?
  isVerified    Boolean           @default(false)
  isPaid        Boolean           @default(false)
  verifiedAt    DateTime?
  returnedAt    DateTime?
  offboardingId String?           @db.Uuid
  asset         Asset             @relation(fields: [assetId], references: [id])
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
  user          User              @relation(fields: [userId], references: [id])
}

model Fault {
  id           String      @id @default(uuid()) @db.Uuid
  assetId      String      @db.Uuid
  reportedById String?     @db.Uuid
  resolvedById String?     @db.Uuid
  images       String[]
  reason       String?
  notes        String?
  status       FaultStatus @default(PENDING)
  resolvedAt   DateTime?   @default(now())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @default(now()) @updatedAt
  asset        Asset       @relation(fields: [assetId], references: [id])
  reportedBy   User?       @relation("reportedBy", fields: [reportedById], references: [id])
  resolvedBy   User?       @relation("resolvedBy", fields: [resolvedById], references: [id])

  @@index([reportedById])
  @@index([resolvedById])
  @@index([assetId])
  @@index([status])
}

model Offboarding {
  id           String                 @id @default(uuid()) @db.Uuid
  type         ExitType
  lastWorkDate DateTime
  reason       String
  noticePeriod Boolean                @default(false)
  status       Status                 @default(PENDING)
  userId       String                 @unique @db.Uuid
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  assignments  Assignment[]
  comment      Comment[]
  handover     HandoverDocument[]
  user         User                   @relation(fields: [userId], references: [id])
  checklist    OffboardingChecklist[]
  payments     Payment[]
  uploads      Upload[]
}

model OffboardingChecklist {
  id            String      @id @default(uuid()) @db.Uuid
  task          String
  status        Status      @default(PENDING)
  offboardingId String      @db.Uuid
  offboarding   Offboarding @relation(fields: [offboardingId], references: [id])
}

model HandoverDocument {
  id            String       @id @default(uuid()) @db.Uuid
  offboardingId String?      @db.Uuid
  isApproved    Boolean      @default(false)
  approvedAt    DateTime?
  notes         String?
  createdAt     DateTime     @default(now())
  comments      Comment[]
  offboarding   Offboarding? @relation(fields: [offboardingId], references: [id])
  upload        Upload[]
}

model Payment {
  id            String       @id @default(uuid()) @db.Uuid
  offboardingId String?      @db.Uuid
  approved      Boolean      @default(false)
  approvedBy    String?      @db.Uuid
  approvedAt    DateTime?
  notes         String?
  createdAt     DateTime     @default(now())
  comment       Comment[]
  offboarding   Offboarding? @relation(fields: [offboardingId], references: [id])
  uploads       Upload[]
}

model Entitlement {
  id        String             @id @default(uuid()) @db.Uuid
  name      String             @unique
  unit      EntitlementUnit
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  request   LeaveRequest[]
  levels    LevelEntitlement[]
}

model LevelEntitlement {
  id            String      @id @default(uuid()) @db.Uuid
  levelId       String      @db.Uuid
  entitlementId String      @db.Uuid
  value         Int?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  entitlement   Entitlement @relation(fields: [entitlementId], references: [id])
  level         Level       @relation(fields: [levelId], references: [id])

  @@unique([levelId, entitlementId])
}

model LeaveRequest {
  id                String         @id @default(uuid()) @db.Uuid
  userId            String         @db.Uuid
  doaId             String         @db.Uuid
  startDate         DateTime
  endDate           DateTime
  duration          Int
  currentApprovalId String?        @db.Uuid
  reason            String
  status            LeaveStatus    @default(PENDING)
  typeId            String         @db.Uuid
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  approvals         Approval[]
  cancelRequest     CancelRequest?
  doa               User           @relation("deedOfAssignement", fields: [doaId], references: [id])
  type              Entitlement    @relation(fields: [typeId], references: [id])
  user              User           @relation("user", fields: [userId], references: [id])
  response          Response[]
  uploads           Upload[]
}

model CancelRequest {
  id        String       @id @default(uuid()) @db.Uuid
  requestId String       @unique @db.Uuid
  reason    String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  request   LeaveRequest @relation(fields: [requestId], references: [id])
}

model Approver {
  id           String      @id @default(uuid()) @db.Uuid
  userId       String      @db.Uuid
  departmentId String?     @db.Uuid
  role         Role
  isActive     Boolean     @default(true)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  department   Department? @relation(fields: [departmentId], references: [id])
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Approval {
  id             String         @id @default(uuid()) @db.Uuid
  leaveRequestId String         @db.Uuid
  phase          Int
  approverId     String         @db.Uuid
  status         ApprovalStatus @default(PENDING)
  note           String?
  actionDate     DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  approver       User           @relation(fields: [approverId], references: [id], onDelete: Cascade)
  leaveRequest   LeaveRequest   @relation(fields: [leaveRequestId], references: [id])

  @@unique([leaveRequestId, phase])
}

model Response {
  id        String        @id @default(uuid()) @db.Uuid
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  type      ResponseType
  userId    String        @db.Uuid
  requestId String?       @db.Uuid
  note      String
  request   LeaveRequest? @relation(fields: [requestId], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Payroll {
  id            String             @id @default(uuid()) @db.Uuid
  salary        Float
  gross         Float
  net           Float
  deductions    Float
  tax           Float?
  cra           Float?
  taxableIncome Float?
  pension       Float?
  nhf           Float?
  laa           Float?
  taxStatus     TaxStatus          @default(PENDING)
  userId        String             @unique @db.Uuid
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  user          User               @relation(fields: [userId], references: [id])
  component     PayrollComponent[]
  payslip       Payslip[]
}

model PayrollComponent {
  id            String                @id @default(uuid()) @db.Uuid
  amount        Float
  type          SalaryType
  title         String
  calculations  SalaryCalculationType
  category      ComponentCategory
  monthlyAmount Float
  annualAmount  Float
  duration      Int?
  startDate     DateTime?
  isActive      Boolean               @default(true)
  payrollId     String                @db.Uuid
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  userId        String?               @db.Uuid
  payroll       Payroll               @relation(fields: [payrollId], references: [id], onDelete: Cascade)
  user          User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Payslip {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  data      Bytes
  userId    String   @db.Uuid
  createdAt DateTime @default(now())
  month     Int
  payrollId String   @db.Uuid
  year      Int
  amount    Float
  payroll   Payroll  @relation(fields: [payrollId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([payrollId])
  @@index([month, year])
}

model Deductions {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  data      Bytes
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  month     String
  pension   Int
  tax       Int

  @@index([id, month])
}

/// ////////////////////////////////////////  ///////////////////////////////////////////
model Claim {
  id            String      @id @default(uuid())
  title         String
  amount        Float
  dateOfExpense DateTime
  description   String?
  notes         String?
  status        ClaimStatus @default(PENDING)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  userId        String      @db.Uuid
  claimId       String      @unique
  claimsId      String
  claimType     ClaimType   @relation(fields: [claimsId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id])
  proofUrls     Upload[]

  @@index([id])
}

model ClaimType {
  id          String   @id @default(uuid())
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  claim       Claim[]
}

model Task {
  id          String     @id @default(uuid()) @db.Uuid
  taskId      String?    @unique
  title       String
  description String?
  startDate   DateTime?
  dueDate     DateTime?
  category    String?
  priority    String?
  status      TaskStatus @default(PENDING_APPROVAL)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  createdBy   User   @relation("CreatedTasks", fields: [createdById], references: [id])
  approvedBy  User?  @relation("ApprovedTasks", fields: [approvedById], references: [id])
  createdById String @db.Uuid

  approvedById String? @db.Uuid

  assignees UserTask[]
  uploads   Upload[]

  // Approval tracking
  approvalStatus      ApprovalStatus @default(PENDING)
  approvalRequestedAt DateTime?
  approvedAt          DateTime?
  rejectionReason     String?

  TaskCategory TaskCategory[]
}

model TaskCategory {
  id         String       @id @db.Uuid
  title      String       @unique
  taskId     String       @db.Uuid
  createdAt  DateTime     @default(now())
  updatedAt  DateTime
  Task       Task         @relation(fields: [taskId], references: [id], onDelete: Cascade)
  Department Department[] @relation("DepartmentToTaskCategory")
}

model UserTask {
  id         String   @id @db.Uuid
  assignedAt DateTime @default(now())
  userId     String   @db.Uuid
  taskId     String   @db.Uuid
  Task       Task     @relation(fields: [taskId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, taskId])
}

enum ApproverRole {
  DEPARTMENT_HEAD
  HR
  CISO
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TaskStatus {
  PENDING_APPROVAL
  APPROVED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum AStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Status {
  PENDING
  ACCEPTED
  DECLINED
  ISSUE_REPORTED
  ACTIVE
  CONFIRMED
  COMPLETED
  IN_PROGRESS
}

enum TaxStatus {
  PENDING
  CALCULATED
  PAID
}

enum SalaryType {
  EARNING
  DEDUCTION
}

enum ComponentCategory {
  CUSTOM_EARNING
  CUSTOM_DEDUCTION
  STATIC_EARNING
  STATIC_DEDUCTION
}

enum SalaryCalculationType {
  PERCENTAGE
  FIXED
}

enum ResponseType {
  COMMENT
  APPROVAL
  DENIAL
}

enum JobType {
  FULL_TIME
  CONTRACT
}

enum MaritalStatus {
  SINGLE
  MARRIED
}

enum Role {
  SUPERADMIN
  ADMIN
  USER
  DEPT_MANAGER
  FACILITY
  HR
  ASSET_MANAGER
  LEAVE_MANAGER
}

enum AssetCategory {
  HARDWARE
  ACCESSORY
  LOGISTICS
  OFFICE_FURNITURE
  SOFTWARE
  SAFETY_EQUIPMENT
  TELECOM
  MEDICAL_EQUIPMENT
  AUDIO_VISUAL
  PAYMENT_DEVICE
  GENERAL
}

enum AssetStatus {
  AVAILABLE
  ASSIGNED
  REPORTED
  FAULTY
  RETIRED
  ACCEPTED
  MAINTENANCE
}

enum AssignmentStatus {
  ASSIGNED
  RETURNED
}

enum FaultStatus {
  PENDING
  IN_REVIEW
  RESOLVED
  REJECTED
}

enum ExitType {
  RESIGNATION
  TERMINATION
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum DepartmentStatus {
  ACTIVE
  INACTIVE
}

enum EntitlementUnit {
  AMOUNT
  DAYS
  OTHERS
}

enum ClaimStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum Gender {
  MALE
  FEMALE
}
