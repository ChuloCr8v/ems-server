generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Notification {
  id          String    @id @default(uuid())
  recipientId String?   @db.Uuid
  actorId     String?   @db.Uuid
  prospectId  String?   @db.Uuid
  type        String
  message     String
  read        Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  actor       User?     @relation("NotificationActor", fields: [actorId], references: [id])
  prospect    Prospect? @relation(fields: [prospectId], references: [id])
  recipient   User?     @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: SetNull)
}

model User {
  id                    String             @id @default(uuid()) @db.Uuid
  eId                   String?            @unique
  personalEmail         String?            @unique
  email                 String?            @unique
  firstName             String
  lastName              String
  phone                 String?
  workPhone             String?
  role                  String?
  gender                String
  duration              String?
  jobType               JobType?
  country               String?
  state                 String?
  address               String?
  startDate             DateTime?
  status                Status             @default(PENDING)
  userRole              Role[]
  maritalStatus         MaritalStatus?
  levelId               String?            @db.Uuid
  prospectId            String?            @unique @db.Uuid
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  dateOfBirth           DateTime?
  approvals             Approval[]
  approver              Approver[]
  assignments           Assignment[]
  bank                  Bank?
  claims                Claim[]
  comment               Comment[]
  contacts              Contacts?
  departmentCreator     Department?        @relation("departmentCreator")
  faultReporter         Fault[]            @relation("reportedBy")
  faultResolver         Fault[]            @relation("resolvedBy")
  invite                Invite[]
  requestDoa            LeaveRequest[]     @relation("deedOfAssignement")
  requests              LeaveRequest[]     @relation("user")
  notificationActor     Notification[]     @relation("NotificationActor")
  notificationRecipient Notification[]     @relation("NotificationRecipient")
  offboarding           Offboarding?
  payroll               Payroll?
  payComponent          PayrollComponent[]
  payslip               Payslip[]
  responses             Response[]

  userDocuments     Upload[]     @relation("UserDocuments")
  level             Level?       @relation(fields: [levelId], references: [id])
  prospect          Prospect?    @relation(fields: [prospectId], references: [id], onDelete: SetNull)
  UserTask          UserTask[]
  departments       Department[] @relation("DepartmentToUser")
  prospectDocuments Upload[]     @relation("ProspectDocuments")

  createdTasks  Task[] @relation("CreatedTasks")
  approvedTasks Task[] @relation("ApprovedTasks")

  taskCategory Category[]
  appraisals   Appraisal[] @relation("Appraised")
  appraisers   Appraisal[] @relation("Appraiser")

  @@index([email])
  @@index([eId])
  @@index([firstName, lastName])
  @@index([levelId])
}

model Department {
  id             String            @id @default(uuid()) @db.Uuid
  name           String            @unique
  createdById    String?           @unique @db.Uuid
  status         DepartmentStatus? @default(ACTIVE)
  approver       Approver[]
  createdBy      User?             @relation("departmentCreator", fields: [createdById], references: [id])
  prospects      Prospect[]        @relation("DepartmentToProspect")
  taskCategories Category[]
  user           User[]            @relation("DepartmentToUser")
  kpiCategories  KpiCategory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Prospect {
  id        String   @id @default(uuid()) @db.Uuid
  email     String   @unique
  firstName String   @default("")
  lastName  String   @default("")
  phone     String
  gender    String
  role      String
  duration  String?
  startDate DateTime
  jobType   JobType

  invite       Invite[]
  notification Notification[]
  upload       Upload[]
  user         User?
  departments  Department[]   @relation("DepartmentToProspect")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Invite {
  id             String    @id @default(uuid()) @db.Uuid
  email          String
  token          String    @unique
  status         Status    @default(PENDING)
  createdAt      DateTime  @default(now())
  expiresAt      DateTime
  acceptedAt     DateTime?
  declinedAt     DateTime?
  sentById       String?   @db.Uuid
  prospectId     String?   @db.Uuid
  declineReasons String[]
  comment        Comment[]
  prospect       Prospect? @relation(fields: [prospectId], references: [id], onDelete: SetNull)
  sentBy         User?     @relation(fields: [sentById], references: [id])
}

model Level {
  id           String             @id @default(uuid()) @db.Uuid
  name         String
  rank         Int
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  entitlements LevelEntitlement[]
  users        User[]
}

model Upload {
  id                String            @id @default(uuid()) @db.Uuid
  name              String
  size              Int
  type              String
  bytes             Bytes?
  key               String?
  order             Int?
  uri               String?
  prospectId        String?           @db.Uuid
  userId            String?           @db.Uuid
  offboardingId     String?           @db.Uuid
  commentId         String?           @db.Uuid
  handoverId        String?           @db.Uuid
  paymentId         String?           @db.Uuid
  assetId           String?           @db.Uuid
  requestId         String?           @db.Uuid
  publicId          String?           @unique
  secureUrl         String?           @unique
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  guarantorId       String?           @db.Uuid
  claimId           String?
  taskId            String?           @db.Uuid
  asset             Asset?            @relation("AssetImages", fields: [assetId], references: [id])
  claim             Claim?            @relation(fields: [claimId], references: [id])
  comment           Comment?          @relation(fields: [commentId], references: [id])
  guarantor         GuarantorContact? @relation(fields: [guarantorId], references: [id])
  handover          HandoverDocument? @relation(fields: [handoverId], references: [id])
  offboarding       Offboarding?      @relation(fields: [offboardingId], references: [id])
  payment           Payment?          @relation(fields: [paymentId], references: [id])
  prospect          Prospect?         @relation(fields: [prospectId], references: [id], onDelete: SetNull)
  request           LeaveRequest?     @relation(fields: [requestId], references: [id])
  Task              Task?             @relation(fields: [taskId], references: [id])
  userDocuments     User?             @relation("UserDocuments", fields: [userId], references: [id])
  prospectDocuments User[]            @relation("ProspectDocuments")
}

model Contacts {
  id        String             @id @default(uuid()) @db.Uuid
  userId    String             @unique @db.Uuid
  createdAt DateTime           @default(now())
  updatedAt DateTime           @default(now()) @updatedAt
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  emergency EmergencyContact[]
  guarantor GuarantorContact[]
  nextOfKin NextOfKin[]
}

model Bank {
  id            String   @id @default(uuid()) @db.Uuid
  bankName      String
  accountName   String
  accountNumber String
  userId        String?  @unique @db.Uuid
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  user          User?    @relation(fields: [userId], references: [id])
}

model NextOfKin {
  id        String    @id @default(uuid()) @db.Uuid
  firstName String
  lastName  String
  phone     String
  contactId String?   @db.Uuid
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  address   String?
  contacts  Contacts? @relation(fields: [contactId], references: [id])
}

model EmergencyContact {
  id           String    @id @default(uuid()) @db.Uuid
  firstName    String
  lastName     String
  phone        String
  contactId    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  address      String?
  relationship String?
  contacts     Contacts? @relation(fields: [contactId], references: [id])
}

model GuarantorContact {
  id           String    @id @default(uuid()) @db.Uuid
  firstName    String
  lastName     String
  phone        String
  contactId    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  address      String?
  relationship String?
  contacts     Contacts? @relation(fields: [contactId], references: [id])
  document     Upload[]
}

enum CommentType {
  REPLY
  COMMENT
}

model Comment {
  id            String            @id @default(uuid()) @db.Uuid
  comment       String
  userId        String?           @db.Uuid
  inviteId      String?           @db.Uuid
  offboardingId String?           @db.Uuid
  paymentId     String?           @db.Uuid
  handoverId    String?           @db.Uuid
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  handover      HandoverDocument? @relation(fields: [handoverId], references: [id])
  invite        Invite?           @relation(fields: [inviteId], references: [id])
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
  payment       Payment?          @relation(fields: [paymentId], references: [id])
  user          User?             @relation(fields: [userId], references: [id])
  uploads       Upload[]

  taskId String? @db.Uuid
  task   Task?   @relation(fields: [taskId], references: [id], onDelete: SetNull)
}

/// ///////////////////////////// ASSETS ///////////////////////
model Asset {
  id           String         @id @default(uuid()) @db.Uuid
  assetId      String         @unique
  name         String
  serialNo     String?        @unique
  category     AssetCategory?
  purchaseDate DateTime?
  vendor       String?
  cost         Float?
  description  String?
  isReturned   Boolean?       @default(false)
  status       AssetStatus?   @default(AVAILABLE)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  assignments  Assignment[]
  faults       Fault[]
  assetImages  Upload[]       @relation("AssetImages")
}

model Assignment {
  id            String            @id @default(uuid())
  assetId       String            @db.Uuid
  userId        String            @db.Uuid
  assignedAt    DateTime
  retrievedAt   DateTime?
  notes         String?
  condition     String?
  status        AssignmentStatus?
  isVerified    Boolean           @default(false)
  isPaid        Boolean           @default(false)
  verifiedAt    DateTime?
  returnedAt    DateTime?
  offboardingId String?           @db.Uuid
  asset         Asset             @relation(fields: [assetId], references: [id])
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
  user          User              @relation(fields: [userId], references: [id])
}

model Fault {
  id           String      @id @default(uuid()) @db.Uuid
  assetId      String      @db.Uuid
  reportedById String?     @db.Uuid
  resolvedById String?     @db.Uuid
  images       String[]
  reason       String?
  notes        String?
  status       FaultStatus @default(PENDING)
  resolvedAt   DateTime?   @default(now())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @default(now()) @updatedAt
  asset        Asset       @relation(fields: [assetId], references: [id])
  reportedBy   User?       @relation("reportedBy", fields: [reportedById], references: [id])
  resolvedBy   User?       @relation("resolvedBy", fields: [resolvedById], references: [id])

  @@index([reportedById])
  @@index([resolvedById])
  @@index([assetId])
  @@index([status])
}

model Offboarding {
  id           String                 @id @default(uuid()) @db.Uuid
  type         ExitType
  lastWorkDate DateTime
  reason       String
  noticePeriod Boolean                @default(false)
  status       Status                 @default(PENDING)
  userId       String                 @unique @db.Uuid
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
  assignments  Assignment[]
  comment      Comment[]
  handover     HandoverDocument[]
  user         User                   @relation(fields: [userId], references: [id])
  checklist    OffboardingChecklist[]
  payments     Payment[]
  uploads      Upload[]
}

model OffboardingChecklist {
  id            String      @id @default(uuid()) @db.Uuid
  task          String
  status        Status      @default(PENDING)
  offboardingId String      @db.Uuid
  offboarding   Offboarding @relation(fields: [offboardingId], references: [id])
}

model HandoverDocument {
  id            String       @id @default(uuid()) @db.Uuid
  offboardingId String?      @db.Uuid
  isApproved    Boolean      @default(false)
  approvedAt    DateTime?
  notes         String?
  createdAt     DateTime     @default(now())
  comments      Comment[]
  offboarding   Offboarding? @relation(fields: [offboardingId], references: [id])
  upload        Upload[]
}

model Payment {
  id            String       @id @default(uuid()) @db.Uuid
  offboardingId String?      @db.Uuid
  approved      Boolean      @default(false)
  approvedBy    String?      @db.Uuid
  approvedAt    DateTime?
  notes         String?
  createdAt     DateTime     @default(now())
  comment       Comment[]
  offboarding   Offboarding? @relation(fields: [offboardingId], references: [id])
  uploads       Upload[]
}

model Entitlement {
  id        String             @id @default(uuid()) @db.Uuid
  name      String             @unique
  unit      EntitlementUnit
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  request   LeaveRequest[]
  levels    LevelEntitlement[]
}

model LevelEntitlement {
  id            String      @id @default(uuid()) @db.Uuid
  levelId       String      @db.Uuid
  entitlementId String      @db.Uuid
  value         Int?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  entitlement   Entitlement @relation(fields: [entitlementId], references: [id])
  level         Level       @relation(fields: [levelId], references: [id])

  @@unique([levelId, entitlementId])
}

model LeaveRequest {
  id                String         @id @default(uuid()) @db.Uuid
  userId            String         @db.Uuid
  doaId             String         @db.Uuid
  startDate         DateTime
  endDate           DateTime
  duration          Int
  currentApprovalId String?        @db.Uuid
  reason            String
  status            LeaveStatus    @default(PENDING)
  typeId            String         @db.Uuid
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  approvals         Approval[]
  cancelRequest     CancelRequest?
  doa               User           @relation("deedOfAssignement", fields: [doaId], references: [id])
  type              Entitlement    @relation(fields: [typeId], references: [id])
  user              User           @relation("user", fields: [userId], references: [id])
  response          Response[]
  uploads           Upload[]
}

model CancelRequest {
  id        String       @id @default(uuid()) @db.Uuid
  requestId String       @unique @db.Uuid
  reason    String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  request   LeaveRequest @relation(fields: [requestId], references: [id])
}

model Approver {
  id           String      @id @default(uuid()) @db.Uuid
  userId       String      @db.Uuid
  departmentId String?     @db.Uuid
  role         Role
  isActive     Boolean     @default(true)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  department   Department? @relation(fields: [departmentId], references: [id])
  user         User        @relation(fields: [userId], references: [id])
}

model Approval {
  id             String         @id @default(uuid()) @db.Uuid
  leaveRequestId String         @db.Uuid
  phase          Int
  approverId     String?        @db.Uuid
  status         ApprovalStatus @default(PENDING)
  note           String?
  actionDate     DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  approver       User?          @relation(fields: [approverId], references: [id], onDelete: SetNull)
  leaveRequest   LeaveRequest   @relation(fields: [leaveRequestId], references: [id])

  @@unique([leaveRequestId, phase])
}

model Response {
  id        String        @id @default(uuid()) @db.Uuid
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  type      ResponseType
  userId    String        @db.Uuid
  requestId String?       @db.Uuid
  note      String
  request   LeaveRequest? @relation(fields: [requestId], references: [id], onDelete: SetNull)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Payroll {
  id            String             @id @default(uuid()) @db.Uuid
  salary        Float
  gross         Float
  net           Float
  deductions    Float
  tax           Float?
  cra           Float?
  taxableIncome Float?
  pension       Float?
  nhf           Float?
  laa           Float?
  taxStatus     TaxStatus          @default(PENDING)
  userId        String             @unique @db.Uuid
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  user          User               @relation(fields: [userId], references: [id])
  component     PayrollComponent[]
  payslip       Payslip[]
}

model PayrollComponent {
  id            String                @id @default(uuid()) @db.Uuid
  amount        Float
  type          SalaryType
  title         String
  calculations  SalaryCalculationType
  category      ComponentCategory
  monthlyAmount Float
  annualAmount  Float
  duration      Int?
  startDate     DateTime?
  isActive      Boolean               @default(true)
  payrollId     String                @db.Uuid
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  userId        String?               @db.Uuid
  payroll       Payroll               @relation(fields: [payrollId], references: [id], onDelete: Cascade)
  user          User?                 @relation(fields: [userId], references: [id], onDelete: SetNull)
}

model Payslip {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  data      Bytes
  userId    String   @db.Uuid
  createdAt DateTime @default(now())
  month     Int
  payrollId String   @db.Uuid
  year      Int
  amount    Float
  payroll   Payroll  @relation(fields: [payrollId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([payrollId])
  @@index([month, year])
}

model Deductions {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  data      Bytes
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  month     String
  pension   Int
  tax       Int

  @@index([id, month])
}

/// //////////////////////////////////////// CLAIMS ///////////////////////////////////////////
model Claim {
  id            String      @id @default(uuid())
  title         String
  amount        Float
  dateOfExpense DateTime
  description   String?
  notes         String?
  status        ClaimStatus @default(PENDING)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  userId        String      @db.Uuid
  claimId       String      @unique
  claimsId      String?
  claimType     ClaimType?  @relation(fields: [claimsId], references: [id], onDelete: SetNull)
  user          User        @relation(fields: [userId], references: [id])
  proofUrls     Upload[]

  @@index([id])
}

model ClaimType {
  id          String   @id @default(uuid())
  title       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  claim       Claim[]
}

/////////////////////////////////////////// PERFORMANCE ////////////////////////////////////////

/////////////////////////////////////////// TASK MANAGEMENT ////////////////////////////////////////
model Task {
  id          String     @id @default(uuid()) @db.Uuid
  taskId      String?    @unique
  title       String
  description String?
  startDate   DateTime?
  dueDate     DateTime?
  category    Category[]
  priority    String?
  status      TaskStatus @default(PENDING_APPROVAL)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  createdBy   User   @relation("CreatedTasks", fields: [createdById], references: [id])
  approvedBy  User?  @relation("ApprovedTasks", fields: [approvedById], references: [id])
  createdById String @db.Uuid

  comments Comment[]

  approvedById String? @db.Uuid

  assignees UserTask[]
  uploads   Upload[]

  // Approval tracking
  approvalStatus      ApprovalStatus @default(PENDING)
  approvalRequestedAt DateTime?
  approvedAt          DateTime?
  rejectionReason     String?
}

model Category {
  id          String  @id @default(uuid()) @db.Uuid
  categoryId  String? @unique
  title       String  @unique
  description String?
  color       String?

  type CategoryType?

  tasks Task[]

  departments Department[]

  userId    String?  @db.Uuid
  createdBy User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserTask {
  id         String   @id @default(uuid()) @db.Uuid
  assignedAt DateTime @default(now())
  userId     String   @db.Uuid
  taskId     String   @db.Uuid
  Task       Task     @relation(fields: [taskId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, taskId])
}

//////////////////////////////////////////  APPRAISAL  ///////////////////////////////////////////

model Appraisal {
  id                  String               @id @default(uuid()) @db.Uuid
  quarter             String
  year                Int
  managerComment      String?
  period              String //e.g Quater 3 2025
  kpi                 Kpi[]
  goalsAndAchievement GoalsAndAchievement?
  feedback            Feedback?
  summary             RatingSummary?
  submittedAt         DateTime?
  appraisedAt         DateTime?
  hrReviewedAt        DateTime?
  autoGenerated       Boolean              @default(true)
  status              AppraisalStatus      @default(GENERATED)
  appraiserId         String               @db.Uuid
  appraiser           User                 @relation("Appraiser", fields: [appraiserId], references: [id])
  appraisedId         String               @db.Uuid // The employee being appraised
  appraised           User                 @relation("Appraised", fields: [appraisedId], references: [id])
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt

  @@unique([quarter, year, appraisedId])
  @@map("appraisals")
}

model Kpi {
  id          String        @id @default(uuid()) @db.Uuid
  appraisalId String?       @unique @db.Uuid
  appraisal   Appraisal?    @relation(fields: [appraisalId], references: [id])
  categories  KpiCategory[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@map("kpis")
}

model KpiCategory {
  id           String          @id @default(uuid()) @db.Uuid
  name         String //e.g., "TECHNICAL SKILL", "TEAM COLLABORATION"
  kpiId        String?         @db.Uuid
  kpi          Kpi?            @relation(fields: [kpiId], references: [id])
  departmentId String?         @db.Uuid
  department   Department?     @relation(fields: [departmentId], references: [id])
  objectives   Objective[]
  type         KpiCategoryType @default(STATIC)
  isGlobal     Boolean         @default(true)
  isApproved   Boolean         @default(false)
  reviewedBy   String?         @db.Uuid // Admin who reviewed the KPIs
  reviewedAt   DateTime? // When the KPIs were reviewed
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@unique([name, departmentId])
  @@map("kpi_categories")
}

model Objective {
  id         String      @id @default(uuid()) @db.Uuid
  name       String //e.g., "Knowledge of Resk./Technologies"
  rating     Float? //Rating (1-5)
  comment    String?
  categoryId String      @db.Uuid
  category   KpiCategory @relation(fields: [categoryId], references: [id])
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  @@map("objectives")
}

model GoalsAndAchievement {
  id           String    @id @default(uuid()) @db.Uuid
  achievements String[]
  goals        String[]
  appraisalId  String    @unique @db.Uuid
  appraisal    Appraisal @relation(fields: [appraisalId], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model Feedback {
  id          String             @id @default(uuid()) @db.Uuid
  questions   FeedbackQuestion[]
  appraisalId String             @unique @db.Uuid
  appraisal   Appraisal          @relation(fields: [appraisalId], references: [id])
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
}

model FeedbackQuestion {
  id         String   @id @default(uuid()) @db.Uuid
  question   String
  response   String?
  feedbackId String   @db.Uuid
  feedback   Feedback @relation(fields: [feedbackId], references: [id])
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model RatingSummary {
  id                    String    @id @default(uuid()) @db.Uuid
  appraisalId           String    @unique @db.Uuid
  appraisal             Appraisal @relation(fields: [appraisalId], references: [id])
  technicalPerformance  Float?
  teamCollaboration     Float?
  initiativesLeadership Float?
  departmentalKpi       Float?
  overallPerformance    Float?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
}

///////////////////////////////////////////// ENUMS  /////////////////////////////////////////////

enum ApproverRole {
  DEPARTMENT_HEAD
  HR
  CISO
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TaskStatus {
  REJECTED
  PENDING_APPROVAL
  APPROVED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum AStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Status {
  PENDING
  ACCEPTED
  DECLINED
  ISSUE_REPORTED
  ACTIVE
  CONFIRMED
  COMPLETED
  IN_PROGRESS
}

enum TaxStatus {
  PENDING
  CALCULATED
  PAID
}

enum SalaryType {
  EARNING
  DEDUCTION
}

enum AppraisalStatus {
  GENERATED // Initial state when quarterly appraisal is generated
  PENDING // Department KPIs added, waiting for admin review
  HR_REVIEW // In review with the HR team
  REVIEWED // Admin has reviewed and approved department KPIs
  DRAFT // Employee is working on their appraisal
  SUBMITTED // Employee has submitted for manager review
  APPRAISED // Manager has reviewed and approved
  COMPLETED // Final state after HR review
}

enum KpiCategoryType {
  STATIC
  DYNAMIC
}

enum ComponentCategory {
  CUSTOM_EARNING
  CUSTOM_DEDUCTION
  STATIC_EARNING
  STATIC_DEDUCTION
}

enum SalaryCalculationType {
  PERCENTAGE
  FIXED
}

enum ResponseType {
  COMMENT
  APPROVAL
  DENIAL
}

enum JobType {
  FULL_TIME
  CONTRACT
}

enum MaritalStatus {
  SINGLE
  MARRIED
}

enum Role {
  SUPERADMIN
  ADMIN
  USER
  DEPT_MANAGER
  FACILITY
  HR
  ASSET_MANAGER
  LEAVE_MANAGER
  TEAM_LEAD
}

enum AssetCategory {
  HARDWARE
  ACCESSORY
  LOGISTICS
  OFFICE_FURNITURE
  SOFTWARE
  SAFETY_EQUIPMENT
  TELECOM
  MEDICAL_EQUIPMENT
  AUDIO_VISUAL
  PAYMENT_DEVICE
  GENERAL
}

enum AssetStatus {
  AVAILABLE
  ASSIGNED
  REPORTED
  FAULTY
  RETIRED
  ACCEPTED
  MAINTENANCE
}

enum AssignmentStatus {
  ASSIGNED
  RETURNED
}

enum FaultStatus {
  PENDING
  IN_REVIEW
  RESOLVED
  REJECTED
}

enum ExitType {
  RESIGNATION
  TERMINATION
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum DepartmentStatus {
  ACTIVE
  INACTIVE
}

enum EntitlementUnit {
  AMOUNT
  DAYS
  OTHERS
}

enum ClaimStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum Gender {
  MALE
  FEMALE
}

enum CategoryType {
  Task
}
