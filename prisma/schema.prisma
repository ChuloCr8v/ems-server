generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/////////////////////////////////  ONBOARDING ////////////////////////////////

model Notification {
  id          String   @id @default(uuid())
  recipientId String   @db.Uuid
  actorId     String?  @db.Uuid
  prospectId  String?  @db.Uuid
  type        String
  message     String
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  recipient User      @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  actor     User?     @relation("NotificationActor", fields: [actorId], references: [id])
  prospect  Prospect? @relation(fields: [prospectId], references: [id])
}

model User {
  id            String       @id @default(uuid()) @db.Uuid
  eId           String?      @unique
  personalEmail String?      @unique
  email         String?      @unique
  firstName     String
  lastName      String
  phone         String?
  workPhone     String?
  role          String?
  gender        String
  duration      String?
  jobType       JobType?
  departments   Department[] // many-to-many

  country       String?
  state         String?
  address       String?
  startDate     DateTime?
  dateOfBirth   DateTime?
  status        Status         @default(PENDING)
  userRole      Role[]
  maritalStatus MaritalStatus?
  contacts      Contacts?
  offboarding   Offboarding?
  payroll       Payroll?

  levelId String? @db.Uuid
  level   Level?  @relation(fields: [levelId], references: [id])

  prospectId String?   @unique @db.Uuid
  prospect   Prospect? @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  prospectDocuments Upload[] @relation("ProspectDocuments")
  userDocuments     Upload[] @relation("UserDocuments")

  invite      Invite[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  comment     Comment[]
  assignments Assignment[]

  faultReporter Fault[] @relation("reportedBy")
  faultResolver Fault[] @relation("resolvedBy")

  departmentCreator Department? @relation("departmentCreator")
  claims            Claim[]

  assignedTasks UserTask[]
  createdTasks  Task[]     @relation("CreatedTasks")

  notificationRecipient Notification[] @relation("NotificationRecipient")
  notificationActor     Notification[] @relation("NotificationActor")

  requestDoa LeaveRequest[] @relation("deedOfAssignement")
  requests   LeaveRequest[] @relation("user")
  approver   Approver[]
  approvals  Approval[]
  responses  Response[]
  bank       Bank?

  payslip      Payslip[]
  payComponent PayrollComponent[]
  // Deductions   Deductions[]

  @@index([email])
  @@index([eId])
  @@index([firstName, lastName])
  @@index([levelId])
}

model Department {
  id   String @id @default(uuid()) @db.Uuid
  name String @unique
  user User[]

  createdBy   User?   @relation("departmentCreator", fields: [createdById], references: [id])
  createdById String? @unique @db.Uuid

  status   DepartmentStatus? @default(ACTIVE)
  approver Approver[]

  prospects Prospect[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Prospect {
  id          String       @id @default(uuid()) @db.Uuid
  email       String       @unique
  firstName   String       @default("")
  lastName    String       @default("")
  phone       String
  gender      String
  role        String
  duration    String?
  startDate   DateTime
  departments Department[]

  jobType      JobType
  user         User?
  invite       Invite[]
  upload       Upload[]
  notification Notification[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
}

model Invite {
  id         String    @id @default(uuid()) @db.Uuid
  email      String
  token      String    @unique
  status     Status    @default(PENDING)
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  acceptedAt DateTime?
  declinedAt DateTime?
  sentById   String?   @db.Uuid
  sentBy     User?     @relation(fields: [sentById], references: [id])
  prospectId String    @db.Uuid
  prospect   Prospect  @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  comment        Comment[]
  declineReasons String[]
}

model Level {
  id           String             @id @default(uuid()) @db.Uuid
  name         String
  rank         Int
  users        User[]
  entitlements LevelEntitlement[]
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
}

model Upload {
  id    String  @id @default(uuid()) @db.Uuid
  name  String
  size  Int
  type  String
  bytes Bytes?
  key   String?
  order Int?
  uri   String?

  prospectId String?   @db.Uuid
  prospect   Prospect? @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  userId            String? @db.Uuid
  userDocuments     User?   @relation("UserDocuments", fields: [userId], references: [id])
  prospectDocuments User[]  @relation("ProspectDocuments")

  offboardingId String?           @db.Uuid
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
  commentId     String?           @db.Uuid
  comment       Comment?          @relation(fields: [commentId], references: [id])
  handoverId    String?           @db.Uuid
  handover      HandoverDocument? @relation(fields: [handoverId], references: [id])
  paymentId     String?           @db.Uuid
  payment       Payment?          @relation(fields: [paymentId], references: [id])
  assetId       String?           @db.Uuid
  asset         Asset?            @relation("AssetImages", fields: [assetId], references: [id])
  requestId     String?           @db.Uuid
  request       LeaveRequest?     @relation(fields: [requestId], references: [id])

  claim   Claim?  @relation(fields: [claimId], references: [id])
  claimId String?

  guarantorId String?           @db.Uuid
  guarantor   GuarantorContact? @relation(fields: [guarantorId], references: [id])

  //cloudinary keys
  publicId  String? @unique
  secureUrl String? @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Contacts {
  id        String             @id @default(uuid()) @db.Uuid
  guarantor GuarantorContact[]
  emergency EmergencyContact[]
  nextOfKin NextOfKin[]
  userId    String             @unique @db.Uuid
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Bank {
  id            String @id @default(uuid()) @db.Uuid
  bankName      String
  accountName   String
  accountNumber String

  userId String? @unique @db.Uuid
  user   User?   @relation(references: [id], fields: [userId])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model NextOfKin {
  id        String    @id @default(uuid()) @db.Uuid
  firstName String
  lastName  String
  phone     String
  address   String?
  contacts  Contacts? @relation(fields: [contactId], references: [id])
  contactId String?   @db.Uuid
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model EmergencyContact {
  id           String    @id @default(uuid()) @db.Uuid
  firstName    String
  lastName     String
  phone        String
  relationship String?
  address      String?
  contacts     Contacts? @relation(fields: [contactId], references: [id])
  contactId    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model GuarantorContact {
  id           String    @id @default(uuid()) @db.Uuid
  firstName    String
  lastName     String
  phone        String
  address      String?
  relationship String?
  document     Upload[]
  contacts     Contacts? @relation(fields: [contactId], references: [id])
  contactId    String?   @db.Uuid
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

model Comment {
  id            String            @id @default(uuid()) @db.Uuid
  comment       String
  userId        String?           @db.Uuid
  user          User?             @relation(fields: [userId], references: [id])
  inviteId      String?           @db.Uuid
  invite        Invite?           @relation(fields: [inviteId], references: [id])
  offboardingId String?           @db.Uuid
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
  paymentId     String?           @db.Uuid
  payment       Payment?          @relation(fields: [paymentId], references: [id])
  handoverId    String?           @db.Uuid
  handover      HandoverDocument? @relation(fields: [handoverId], references: [id])
  uploads       Upload[]
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
}

//////////////////////////////// ASSETS ///////////////////////
model Asset {
  id           String         @id @default(uuid()) @db.Uuid
  assetId      String         @unique
  name         String
  serialNo     String?        @unique
  category     AssetCategory?
  purchaseDate DateTime?
  vendor       String?
  cost         Float?
  assetImages  Upload[]       @relation("AssetImages")
  description  String?
  isReturned   Boolean?       @default(false)
  status       AssetStatus?   @default(AVAILABLE)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  assignments  Assignment[]
  faults       Fault[]
}

model Assignment {
  id            String            @id @default(uuid())
  asset         Asset             @relation(fields: [assetId], references: [id])
  assetId       String            @db.Uuid
  user          User              @relation(fields: [userId], references: [id])
  userId        String            @db.Uuid
  assignedAt    DateTime
  retrievedAt   DateTime?
  notes         String?
  condition     String?
  status        AssignmentStatus?
  isVerified    Boolean           @default(false)
  isPaid        Boolean           @default(false)
  verifiedAt    DateTime?
  returnedAt    DateTime?
  offboardingId String?           @db.Uuid
  offboarding   Offboarding?      @relation(fields: [offboardingId], references: [id])
}

model Fault {
  id           String      @id @default(uuid()) @db.Uuid
  assetId      String      @db.Uuid
  asset        Asset       @relation(fields: [assetId], references: [id])
  reportedById String?     @db.Uuid
  reportedBy   User?       @relation("reportedBy", fields: [reportedById], references: [id])
  resolvedById String?     @db.Uuid
  resolvedBy   User?       @relation("resolvedBy", fields: [resolvedById], references: [id])
  images       String[]
  reason       String?
  notes        String?
  status       FaultStatus @default(PENDING)
  resolvedAt   DateTime?   @default(now())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @default(now()) @updatedAt

  @@index([reportedById])
  @@index([resolvedById])
  @@index([assetId])
  @@index([status])
}

///////////////////////////   OFFBOARDING ///////////////////////

model Offboarding {
  id           String                 @id @default(uuid()) @db.Uuid
  type         ExitType
  lastWorkDate DateTime
  reason       String
  noticePeriod Boolean                @default(false)
  status       Status                 @default(PENDING)
  userId       String                 @unique @db.Uuid
  user         User                   @relation(fields: [userId], references: [id])
  uploads      Upload[]
  checklist    OffboardingChecklist[]
  handover     HandoverDocument[]
  comment      Comment[]
  payments     Payment[]
  assignments  Assignment[]
  createdAt    DateTime               @default(now())
  updatedAt    DateTime               @updatedAt
}

model OffboardingChecklist {
  id            String      @id @default(uuid()) @db.Uuid
  task          String
  status        Status      @default(PENDING)
  // proof   Upload[]
  offboardingId String      @db.Uuid
  offboarding   Offboarding @relation(fields: [offboardingId], references: [id])
}

model HandoverDocument {
  id            String       @id @default(uuid()) @db.Uuid
  offboardingId String?      @db.Uuid
  offboarding   Offboarding? @relation(fields: [offboardingId], references: [id])
  upload        Upload[]
  comments      Comment[]
  isApproved    Boolean      @default(false)
  approvedAt    DateTime?
  notes         String?
  createdAt     DateTime     @default(now())
}

model Payment {
  id            String       @id @default(uuid()) @db.Uuid
  offboardingId String?      @db.Uuid
  offboarding   Offboarding? @relation(fields: [offboardingId], references: [id])
  approved      Boolean      @default(false)
  approvedBy    String?      @db.Uuid
  approvedAt    DateTime?
  notes         String?
  uploads       Upload[]
  comment       Comment[]
  createdAt     DateTime     @default(now())
}

///////////////////////////////// LEAVE ///////////////////////////////////////////////////

model Entitlement {
  id        String             @id @default(uuid()) @db.Uuid
  name      String             @unique
  unit      EntitlementUnit
  levels    LevelEntitlement[]
  request   LeaveRequest[]
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
}

model LevelEntitlement {
  id            String      @id @default(uuid()) @db.Uuid
  level         Level       @relation(fields: [levelId], references: [id])
  levelId       String      @db.Uuid
  entitlement   Entitlement @relation(fields: [entitlementId], references: [id])
  entitlementId String      @db.Uuid
  value         Int? // The value of the entitlement for this level
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([levelId, entitlementId])
}

model LeaveRequest {
  id                String         @id @default(uuid()) @db.Uuid
  userId            String         @db.Uuid
  user              User           @relation("user", fields: [userId], references: [id])
  doaId             String         @db.Uuid
  doa               User           @relation("deedOfAssignement", fields: [doaId], references: [id])
  startDate         DateTime
  endDate           DateTime
  duration          Int
  currentApprovalId String?        @db.Uuid
  reason            String
  status            LeaveStatus    @default(PENDING)
  typeId            String         @db.Uuid
  type              Entitlement    @relation(fields: [typeId], references: [id])
  cancelRequest     CancelRequest?
  response          Response[]
  uploads           Upload[]
  approvals         Approval[]
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
}

model CancelRequest {
  id        String       @id @default(uuid()) @db.Uuid
  requestId String       @unique @db.Uuid
  request   LeaveRequest @relation(fields: [requestId], references: [id])
  reason    String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}

model Approver {
  id           String      @id @default(uuid()) @db.Uuid
  userId       String      @db.Uuid
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  departmentId String?     @db.Uuid
  department   Department? @relation(fields: [departmentId], references: [id])
  role         Role
  isActive     Boolean     @default(true)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
}

model Approval {
  id             String         @id @default(uuid()) @db.Uuid
  leaveRequest   LeaveRequest   @relation(fields: [leaveRequestId], references: [id])
  leaveRequestId String         @db.Uuid
  phase          Int
  approver       User           @relation(fields: [approverId], references: [id], onDelete: Cascade)
  approverId     String         @db.Uuid
  status         ApprovalStatus @default(PENDING)
  note           String?
  actionDate     DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@unique([leaveRequestId, phase])
}

enum ApproverRole {
  DEPARTMENT_HEAD
  HR
  CISO
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

model Response {
  id        String        @id @default(uuid()) @db.Uuid
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  type      ResponseType
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String        @db.Uuid
  request   LeaveRequest? @relation(fields: [requestId], references: [id], onDelete: Cascade)
  requestId String?       @db.Uuid
  note      String
}

///////////////////////////////////// PAYROLL ////////////////////////////////////////////////////

model Payroll {
  id            String             @id @default(uuid()) @db.Uuid
  salary        Float
  gross         Float
  net           Float
  deductions    Float
  tax           Float?
  cra           Float?
  taxableIncome Float?
  pension       Float?
  nhf           Float?
  laa           Float?
  taxStatus     TaxStatus          @default(PENDING)
  userId        String             @unique @db.Uuid
  user          User               @relation(fields: [userId], references: [id])
  component     PayrollComponent[]
  payslip       Payslip[]
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
}

model PayrollComponent {
  id            String                @id @default(uuid()) @db.Uuid
  amount        Float //PERCENTAGE or FIXED
  type          SalaryType
  title         String
  calculations  SalaryCalculationType
  category      ComponentCategory
  monthlyAmount Float
  annualAmount  Float
  duration      Int?
  startDate     DateTime?
  isActive      Boolean               @default(true)
  payrollId     String                @db.Uuid
  payroll       Payroll               @relation(fields: [payrollId], references: [id], onDelete: Cascade)
  userId        String?               @db.Uuid
  user          User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Payslip {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  amount    Float
  month     Int
  year      Int
  data      Bytes
  userId    String   @db.Uuid
  user      User     @relation(fields: [userId], references: [id])
  payrollId String   @db.Uuid
  payroll   Payroll  @relation(fields: [payrollId], references: [id])
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([payrollId])
  @@index([month, year])
}

model Deductions {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  // amount    Float
  tax       Int
  pension   Int
  month     String
  // year      Int
  data      Bytes
  // userId    String   @db.Uuid
  // user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // @@index([userId])
  // @@index([month, year])
}

///////////////////////////////////////////  ///////////////////////////////////////////
model Claim {
  id            String      @id @default(uuid())
  title         String
  claimType     ClaimType
  claimId       String?     @unique()
  amount        Float
  dateOfExpense DateTime
  description   String?
  notes         String?
  status        ClaimStatus @default(PENDING)
  proofUrls     Upload[]
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  userId        String      @db.Uuid
  user          User        @relation(fields: [userId], references: [id])

  @@map("claims")
}

model Task {
  id          String      @id @default(uuid())
  title       String
  description String?
  startDate   DateTime?
  dueDate     DateTime?
  category    String?
  priority    Priority?
  status      TaskStatus?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  assignees   UserTask[]
  files       TaskFile[]
  createdBy   User       @relation("CreatedTasks", fields: [createdById], references: [id])
  createdById String     @db.Uuid

  @@map("tasks")
}

model UserTask {
  id         String   @id @default(cuid())
  taskId     String
  userId     String   @db.Uuid
  assignedAt DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])

  @@unique([taskId, userId])
  @@map("user_tasks")
}

model TaskFile {
  id           String   @id @default(cuid())
  filename     String
  originalName String
  path         String
  mimetype     String
  size         Int
  taskId       String
  uploadedAt   DateTime @default(now())

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@map("task_files")
}

///////////////////////////////////////////// ENUMS  /////////////////////////////////////////////

enum Status {
  PENDING
  ACCEPTED
  DECLINED
  ISSUE_REPORTED
  ACTIVE
  CONFIRMED
  COMPLETED
  IN_PROGRESS
}

enum TaxStatus {
  PENDING
  CALCULATED
  PAID
}

enum SalaryType {
  EARNING
  DEDUCTION
}

enum ComponentCategory {
  CUSTOM_EARNING
  CUSTOM_DEDUCTION
  STATIC_EARNING
  STATIC_DEDUCTION
}

enum SalaryCalculationType {
  PERCENTAGE
  FIXED
}

enum ResponseType {
  COMMENT
  APPROVAL
  DENIAL
}

enum JobType {
  FULL_TIME
  CONTRACT
}

enum MaritalStatus {
  SINGLE
  MARRIED
}

enum Role {
  SUPERADMIN
  ADMIN
  USER
  DEPT_MANAGER
  FACILITY
  HR
  ASSET_MANAGER
  LEAVE_MANAGER
}

enum AssetCategory {
  HARDWARE // Laptops, desktops, monitors, printers, scanners, etc.
  ACCESSORY // ID cards, bags, keys, stamps, clip pads
  LOGISTICS // Transport, delivery-related items (still available if needed)
  OFFICE_FURNITURE // Desks, chairs, etc.
  SOFTWARE // Licensed software, apps
  SAFETY_EQUIPMENT // Safety jackets, raincoats, toolboxes, splicers

  TELECOM // SIM cards, hotspots, routers
  MEDICAL_EQUIPMENT // BP Monitor, health-related devices
  AUDIO_VISUAL // Cameras, webcams, lights, mics, gimbals, speakers
  PAYMENT_DEVICE // POS machines, financial devices
  GENERAL
}

enum AssetStatus {
  AVAILABLE
  ASSIGNED
  REPORTED
  FAULTY
  RETIRED
  ACCEPTED
  MAINTENANCE
}

enum AssignmentStatus {
  ASSIGNED
  RETURNED
}

enum FaultStatus {
  PENDING
  IN_REVIEW
  RESOLVED
  REJECTED
}

enum ExitType {
  RESIGNATION
  TERMINATION
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum DepartmentStatus {
  ACTIVE
  INACTIVE
}

enum EntitlementUnit {
  AMOUNT
  DAYS
  OTHERS
}

enum ClaimStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ClaimType {
  TRAVEL
  MATERIAL
  LOGISTIC
  REPAIR
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Gender {
  MALE
  FEMALE
}
